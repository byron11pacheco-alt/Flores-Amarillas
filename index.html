<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Feliz 21 de Septiembre — Animación Optimizada</title>
<style>
  :root{
    --accent1:#ffd700;
    --accent2:#ff6b6b;
    --bg1:#03102a;
    --bg2:#07254a;
  }
  html,body{ height:100%; margin:0; background:var(--bg1); font-family: "Segoe UI", Roboto, Arial, sans-serif; overflow:hidden; }
  canvas{ display:block; width:100vw; height:100vh; }

  /* UI portada */
  #ui { position:absolute; inset:0; z-index:40; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .cover { pointer-events:auto; text-align:center; }
  .title {
    font-size:48px; margin:0; padding:8px 14px; display:inline-block; background:linear-gradient(90deg,#ff77d2,#ffd700,#5ee3b3,#7fb3ff); -webkit-background-clip:text; background-clip:text; color:transparent;
    font-weight:800; letter-spacing:1px; text-shadow:0 4px 18px rgba(0,0,0,0.6);
    animation:glow 2.2s ease-in-out infinite alternate;
  }
  .subtitle { font-size:18px; color:var(--accent2); margin:8px 0 14px 0; }
  @keyframes glow {
    from { filter: drop-shadow(0 0 8px rgba(255,120,200,0.4)); transform:translateY(-2px); }
    to { filter: drop-shadow(0 0 22px rgba(255,220,70,0.9)); transform:translateY(2px); }
  }
  #startBtn {
    pointer-events:auto; margin-top:8px; background:linear-gradient(180deg,#fff176,#ffb300); border:0; padding:12px 26px; border-radius:26px; font-size:18px; cursor:pointer;
    box-shadow:0 8px 26px rgba(0,0,0,0.45);
  }

  /* small badge for turtle/moon */
  .badge { position:absolute; z-index:41; left:12px; top:12px; color:#ddd; font-weight:700; display:flex; gap:10px; align-items:center; font-size:13px; pointer-events:none; }
  .dot { width:14px; height:14px; border-radius:50%; box-shadow:0 0 10px rgba(0,0,0,0.35); }
  .dot.turtle { background:#2ecc71; box-shadow:0 0 10px rgba(46,204,113,0.5); }
  .dot.moon { background:#fff; box-shadow:0 0 14px rgba(255,255,255,0.85); }

  #audioNotice { position:absolute; right:12px; bottom:12px; z-index:41; color:#bbb; font-size:12px; }
</style>
</head>
<body>

<div id="ui">
  <div class="cover" id="cover">
    <h1 class="title">Feliz 21 de Septiembre</h1>
    <div class="subtitle">Esto faltaba</div>
    <button id="startBtn">Presiona aquí 🌼</button>
  </div>
</div>

<div class="badge" id="badge" style="display:none;">
  <div style="display:flex;gap:8px;align-items:center;">
    <div class="dot turtle"></div> Tortuga
  </div>
  <div style="width:14px"></div>
  <div style="display:flex;gap:8px;align-items:center;">
    <div class="dot moon"></div> Luna
  </div>
</div>

<div id="audioNotice">Pulsa para iniciar audio</div>
<audio id="bgMusic" src="https://www.bensound.com/bensound-music/bensound-romantic.mp3" preload="auto"></audio>
<canvas id="c"></canvas>

<script>
/* ========= Setup ========= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false }); // opaque canvas for speed
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

const startBtn = document.getElementById('startBtn');
const cover = document.getElementById('cover');
const bgMusic = document.getElementById('bgMusic');
const badge = document.getElementById('badge');
const audioNotice = document.getElementById('audioNotice');

/* ========= Texts timing (overlap: 10s each, start next after 5s) ========= */
const texts = [
  "Si los astronautas te vieran, no necesitarían salir de la tierra para explorar la grandeza",
  "En tus ojos, veo el sol; en tu cabello el amor; en tu cuerpo, el valor; y en tu sonrisa, la perfección",
  "“Si hago cosas no es para que me quieras, sino para que veas que te quiero” — Mario Benedetti",
  "Si no es eterno, que sea inolvidable",
  "Y fin colorado, este amor ha comenzado",
  "¡Te amo de aquí a la Luna, a pasitos de tortuga!"
];
const TEXT_DURATION = 10000; // each shown 10s
const TEXT_STEP = 5000;      // start next after 5s (so overlap of 5s)
let startTime = null;

/* ========= Particle classes & limits ========= */
class Particle {
  constructor(x,y,color,size,vx,vy,life=Infinity){
    this.x=x; this.y=y; this.color=color; this.size=size; this.vx=vx; this.vy=vy;
    this.life = life; this.age=0; this.alpha=1;
  }
  update(dt){
    this.age += dt;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    if(this.age > this.life) this.alpha -= 0.6*dt; // fade
  }
  draw(){
    if(this.alpha <= 0) return;
    ctx.globalAlpha = Math.max(0, this.alpha);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

/* ========= World state ========= */
let stem = [];           // stem particles (brown vertical points) persistent
let center = [];         // center yellow particles
let leaves = [];         // green leaf particles
let sparkles = [];       // golden sparkles around center (grows)
let smallFlowers = [];   // array of flower objects (each has its own arrays)
let hearts = [];         // turtle trail
let explosion = [];      // final explosion
let particlesLimit = 6000; // absolute safety cap for total particles

/* ========= Flower positions ========= */
function centerX(){ return W/2; }
function centerY(){ return H*0.68; }

/* ========= Turtle & Moon ========= */
const turtle = {x:0,y:0,r:8,visible:false, arrived:false};
const moon = {x: null, y: null, r:36, visible:false};

/* ========= Performance helpers ========= */
function totalParticleCount(){
  return stem.length + center.length + leaves.length + sparkles.length + hearts.length + explosion.length + smallFlowers.reduce((s,f)=>s+f.total(),0);
}

/* ========= Initialize main flower (not all at once; we will grow) ========= */
function initMainFlower(){
  // Start with a short stem (seed) and small center
  for(let i=0;i<40;i++){
    const sx = centerX() + (Math.random()-0.5)*6;
    const sy = centerY() + 80 + Math.random()*40;
    stem.push(new Particle(sx, sy, '#5a3518', 2.2, 0, -6, 3 + Math.random()*2));
  }
  for(let i=0;i<120;i++){
    const ang = Math.random()*Math.PI*2;
    const r = Math.sqrt(Math.random())*18;
    center.push(new Particle(centerX() + Math.cos(ang)*r, centerY() - Math.sin(ang)*r*0.6, `hsl(${40+Math.random()*30},95%,${45+Math.random()*10}%)`, 1 + Math.random()*1.6, 0,0, 2 + Math.random()*2));
  }
}

/* ========= Small-flower helper (spawned sparsely across screen) ========= */
function spawnSmallFlower(x,y,scale=1){
  // Each small flower keeps its own arrays to easier manage count
  const f = {
    stem: [],
    center: [],
    leaves: [],
    t: 0,
    total(){ return this.stem.length + this.center.length + this.leaves.length; }
  };
  // modest sizes so not heavy
  for(let i=0;i<20*scale;i++){
    const sx = x + (Math.random()-0.5)*10*scale;
    const sy = y + (Math.random()*30*scale);
    f.stem.push(new Particle(sx, sy, '#5a3518', 1.6, 0, -4 - Math.random()*2, 2 + Math.random()*3));
  }
  for(let i=0;i<80*scale;i++){
    const ang = Math.random() * Math.PI*2;
    const r = Math.sqrt(Math.random()) * (8*scale);
    f.center.push(new Particle(x + Math.cos(ang)*r, y - Math.sin(ang)*r*0.6, `hsl(${40+Math.random()*30},95%,${45+Math.random()*10}%)`, 0.9 + Math.random()*1.2, 0,0, 2 + Math.random()*2));
  }
  for(let i=0;i<30*scale;i++){
    const px = x + (Math.random()-0.5)*40*scale;
    const py = y - Math.random()*30*scale;
    f.leaves.push(new Particle(px, py, `hsl(${110+Math.random()*30},60%,${30+Math.random()*12}%)`, 1 + Math.random()*1.2, (Math.random()-0.5)*0.2, (Math.random()-0.4)*0.2, 2 + Math.random()*2));
  }
  smallFlowers.push(f);
}

/* ========= Growth functions that gradually add particles ========= */
let lastGrowth = 0;
function growMainFlower(dt, elapsed){
  // Keep adding a few stem particles upward to simulate growth
  if(stem.length < 220 && Math.random() < 0.9){
    const topY = Math.min(...stem.map(s=>s.y));
    const newY = topY - (6 + Math.random()*4);
    const xJit = (Math.random()-0.5)*8;
    stem.push(new Particle(centerX() + xJit, Math.max(newY, centerY()+10), '#5a3518', 2.4, 0, -6 - Math.random()*2, 3 + Math.random()*2));
  }

  // Add golden sparkles gradually; rate increases near end
  const progress = Math.min(1, elapsed / 70000); // ~70s to full intensity
  const sparkleSpawnRate = 8 + Math.floor(progress * 120); // up to ~128/sec but we'll spawn per frame limited
  const spawnThisFrame = Math.floor(sparkleSpawnRate * dt);
  for(let i=0;i<spawnThisFrame;i++){
    if(totalParticleCount() > particlesLimit) break;
    const ang = Math.random()*Math.PI*2;
    const rad = 40 + Math.random()*200;
    const px = centerX() + Math.cos(ang)*rad;
    const py = centerY() - Math.sin(ang)*rad*0.6 - Math.random()*20;
    const hue = 40 + Math.random()*30;
    const vx = (centerX() - px) * (0.02 + Math.random()*0.03);
    const vy = (centerY() - py) * (0.02 + Math.random()*0.03);
    sparkles.push(new Particle(px, py, `hsl(${hue},100%,55%)`, 0.9 + Math.random()*1.6, vx, vy, 0.6 + Math.random()*2.0));
  }

  // Grow center slightly: add a few center particles over time
  if(center.length < 700 && Math.random() < 0.9){
    const ang = Math.random()*Math.PI*2;
    const r = Math.sqrt(Math.random())*48;
    center.push(new Particle(centerX() + Math.cos(ang)*r, centerY() - Math.sin(ang)*r*0.6, `hsl(${40+Math.random()*30},95%,${45+Math.random()*10}%)`, 1 + Math.random()*1.8, 0,0, 3 + Math.random()*3));
  }

  // After some elapsed time, spawn large green leaf clusters gradually
  if(elapsed > 22000 && leaves.length < 900 && Math.random() < 0.6){
    // left or right
    const side = Math.random() < 0.5 ? -1 : 1;
    const lx = centerX() + side * (60 + Math.random()*80);
    const ly = centerY() - (20 + Math.random()*80);
    // create cluster
    for(let i=0;i<18;i++){
      const px = lx + (Math.random()-0.5)*60;
      const py = ly + (Math.random()-0.5)*40;
      leaves.push(new Particle(px, py, `hsl(${110+Math.random()*30},60%,${30+Math.random()*10}%)`, 3 + Math.random()*4, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, 6 + Math.random()*4));
    }
  }
}

/* ========= Spawn a few small flowers distributed across screen (but few) ========= */
let smallFlowersSpawned = false;
function maybeSpawnSmallFlowers(){
  if(smallFlowersSpawned) return;
  // spawn 5 small flowers across different x positions and varied y near bottom half
  const positions = 5;
  for(let i=0;i<positions;i++){
    const x = (0.12 + 0.76 * (i / (positions - 1))) * W + (Math.random()-0.5)*80;
    const y = centerY() + (Math.random()*60 - 10) + (i%2 ? 20 : -10);
    const scale = 0.6 + Math.random()*0.6;
    spawnSmallFlower(x, y, scale);
  }
  smallFlowersSpawned = true;
}

/* ========= Turtle movement logic ========= */
let turtleStarted = false;
function startTurtle(){
  if(turtleStarted) return;
  turtleStarted = true;
  turtle.visible = true;
  turtle.x = centerX() + 20;
  turtle.y = centerY() - 40;
  moon.x = W * 0.85;
  moon.y = H * 0.18;
  moon.visible = true;
  badge.style.display = 'inline-flex';
}

/* ========= Final explosion when turtle reaches moon ========= */
let finalTriggered = false;
function triggerFinalBurst(){
  if(finalTriggered) return;
  finalTriggered = true;
  // explosion from moon and from center
  for(let i=0;i<360;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = 30 + Math.random()*90;
    explosion.push(new Particle(moon.x + (Math.random()-0.5)*60, moon.y + (Math.random()-0.5)*60, `hsl(${Math.random()*360},90%,55%)`, 1 + Math.random()*3, Math.cos(angle)*speed, Math.sin(angle)*speed, 1.5 + Math.random()*2));
  }
  for(let i=0;i<500;i++){
    const ang = Math.random()*Math.PI*2;
    const r = Math.sqrt(Math.random())*80;
    const px = centerX() + Math.cos(ang)*r;
    const py = centerY() - Math.sin(ang)*r*0.6;
    explosion.push(new Particle(px, py, `hsl(${Math.random()*360},90%,55%)`, 1 + Math.random()*2.5, (Math.random()-0.5)*40, (Math.random()-0.5)*40, 1.8 + Math.random()*2.5));
  }
}

/* ========= Drawing background (painterly) ========= */
function drawBackground(frame){
  // gradient base
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, '#041433');
  g.addColorStop(0.6, '#052a63');
  g.addColorStop(1, '#07182b');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // subtle brush strokes
  const stripes = 28;
  for(let i=0;i<stripes;i++){
    const hue = 210 + Math.sin((frame+i*13)/120)*18;
    ctx.fillStyle = `hsla(${hue},50%,${8 + (i%2?6:2)}%, ${0.03 + Math.abs(Math.sin((frame+i*7)/140))*0.04})`;
    const px = (i/stripes)*W + (Math.sin((frame+i*17)/100)*40);
    ctx.fillRect(px, i*36 - 44, W/stripes + 60, 80);
  }
  // some faint stars
  ctx.globalAlpha = 0.45;
  for(let i=0;i<70;i++){
    const sx = (i*73 % W) + (Math.sin((frame+i*11)/50)*6);
    const sy = (i*41 % (H*0.45)) + (Math.cos((frame+i*9)/40)*6);
    const s = 0.5 + ((i%7)/7)*1.6;
    ctx.fillStyle = `hsl(${45 + (i%10)}, 90%, ${72 - (i%4)*10}%)`;
    ctx.beginPath();
    ctx.arc(sx, sy, s, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

/* ========= Main loop ========= */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.04, (now - last)/1000); // clamp dt
  last = now;
  ctx.clearRect(0,0,W,H);

  // draw background
  drawBackground(now/40);

  // growth and spawning
  const elapsed = startTime ? (now - startTime) : 0;
  if(startTime){
    growMainFlower(dt, elapsed);
    if(elapsed > 3500) maybeSpawnSmallFlowers();
  }

  // update all particle arrays
  const lists = [stem, center, leaves, sparkles, hearts, explosion];
  lists.forEach(list=>list.forEach(p=>p.update(dt)));
  smallFlowers.forEach(f=>{
    f.stem.forEach(p=>p.update(dt));
    f.center.forEach(p=>p.update(dt));
    f.leaves.forEach(p=>p.update(dt));
    f.t += dt;
  });

  // remove faded ones (lightweight sweep)
  function tidy(list){ for(let i=list.length-1;i>=0;i--){ if(list[i].alpha <= 0.01) list.splice(i,1); } }
  tidy(sparkles); tidy(hearts); tidy(explosion);
  // keep center/stem/leaves but they fade slowly, we clear only if alpha zero
  tidy(center); tidy(stem); tidy(leaves);

  // Draw order: small flowers (behind) -> stems -> leaves -> center -> sparkles -> turtle/ moon -> explosion
  // small flowers (each)
  ctx.save(); ctx.globalCompositeOperation = 'lighter';
  smallFlowers.forEach(f=>{
    f.stem.forEach(p=>p.draw());
    f.leaves.forEach(p=>p.draw());
    f.center.forEach(p=>p.draw());
  });

  // main stem
  stem.forEach(p=>p.draw());
  // leaves
  leaves.forEach(p=>p.draw());
  // center
  center.forEach(p=>p.draw());
  // sparkles (gold)
  sparkles.forEach(p=>p.draw());
  // hearts (turtle trail)
  hearts.forEach(p=>p.draw());
  ctx.restore();

  // moon draw (if visible)
  if(moon.visible){
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 22;
    ctx.shadowColor = 'rgba(255,255,255,0.9)';
    ctx.arc(moon.x, moon.y, moon.r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // turtle movement / draw
  if(turtle.visible && !turtle.arrived){
    // move toward moon slowly
    const dx = moon.x - turtle.x;
    const dy = moon.y - turtle.y;
    const d = Math.hypot(dx,dy);
    if(d > 6){
      const speed = 20 * (1 + Math.min(2, (sparkles.length/120))); // speed scales moderately
      const sx = (dx / d) * speed * dt;
      const sy = (dy / d) * speed * dt;
      turtle.x += sx; turtle.y += sy;
      // leave a small heart trail occasionally
      if(Math.random() < 0.14 && totalParticleCount() < particlesLimit){
        hearts.push(new Particle(turtle.x + (Math.random()-0.5)*4, turtle.y + (Math.random()-0.5)*4, '#ff4d6d', 2 + Math.random()*1.6, (Math.random()-0.5)*8, -Math.random()*6, 0.9 + Math.random()*0.8));
      }
    } else {
      turtle.arrived = true;
      // final trigger
      triggerFinalBurst();
    }
    // draw turtle (green dot)
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#2ecc71';
    ctx.arc(turtle.x, turtle.y, turtle.r, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.stroke();
    ctx.restore();
  }

  // explosion draw & update (already updated above)
  explosion.forEach(p=>p.draw());

  // show texts: overlayed with overlap
  if(startTime){
    const tElapsed = now - startTime;
    // show any text whose start time <= now < start+TEXT_DURATION
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '700 26px "Segoe UI", Arial';
    // draw a translucent backdrop rectangle for readability
    const boxW = Math.min(W*0.9, 1000);
    const boxH = 64;
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.fillRect(W/2 - boxW/2, 36, boxW, boxH);

    for(let i=0;i<texts.length;i++){
      const tStart = i * TEXT_STEP; // next text starts every TEXT_STEP ms
      const tEnd = tStart + TEXT_DURATION;
      if(tElapsed >= tStart && tElapsed <= tEnd){
        // ease alpha depending on proximity to edges
        let alpha = 1;
        const fadeIn = Math.min(0.25, (tElapsed - tStart) / 400);
        if(tElapsed - tStart < 600) alpha = Math.max(0.25, (tElapsed - tStart) / 600);
        if(tEnd - tElapsed < 600) alpha = Math.max(0.25, (tEnd - tElapsed) / 600);
        ctx.globalAlpha = alpha;
        // white-ish text with slight shadow
        ctx.fillStyle = '#eaeaea';
        ctx.fillText(texts[i], W/2, 68);
        ctx.globalAlpha = 1;
      }
    }
    ctx.restore();
  } else {
    // initial prompt
    ctx.save();
    ctx.textAlign='center';
    ctx.fillStyle='#ddd';
    ctx.font='20px "Segoe UI"';
    ctx.fillText('Pulsa "Presiona aquí 🌼" para iniciar', W/2, H*0.6);
    ctx.restore();
  }

  // when final explosion triggered, show final message centered
  if(finalTriggered){
    ctx.save();
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font='700 44px "Segoe UI"';
    // colorful shadow layers
    for(let s=0;s<6;s++){
      ctx.fillStyle = `hsla(${s*60 + (performance.now()%360)}, 90%, 60%, 0.08)`;
      ctx.fillText('FIN. NO SERÁS ESPECTADORA', W/2 + (s-3)*2, H/2 + (s-3)*2);
    }
    ctx.fillStyle = '#fff';
    ctx.fillText('FIN. NO SERÁS ESPECTADORA', W/2, H/2);
    ctx.restore();
  }

  last = now;
  requestAnimationFrame(loop);
}

/* ========= Start animation (bound to click) ========= */
function startAll(){
  if(startTime) return;
  startTime = performance.now();
  // hide cover UI
  cover.style.display = 'none';
  audioNotice.style.display = 'none';
  // play audio
  bgMusic.currentTime = 0;
  bgMusic.play().catch(()=>{ /* ignore if browser blocks until gesture */ });
  // initial spawn
  initMainFlower();
  // spawn few initial sparkles
  for(let i=0;i<80;i++){
    const ang = Math.random()*Math.PI*2;
    const rad = 40 + Math.random()*220;
    const px = centerX() + Math.cos(ang)*rad;
    const py = centerY() - Math.sin(ang)*rad*0.6 - Math.random()*20;
    const hue = 40 + Math.random()*30;
    const vx = (centerX() - px) * (0.02 + Math.random()*0.02);
    const vy = (centerY() - py) * (0.02 + Math.random()*0.02);
    sparkles.push(new Particle(px, py, `hsl(${hue},100%,55%)`, 0.9 + Math.random()*1.8, vx, vy, 0.9 + Math.random()*2.2));
  }
  // schedule small flowers a bit later to avoid initial jump
  setTimeout(()=> maybeSpawnSmallFlowers(), 1600);
  // start loop
  last = performance.now();
  requestAnimationFrame(loop);
  // also schedule turtle start to align with the 6th text timing:
  const sixStart = 5 * TEXT_STEP; // the 6th text starts at index 5
  setTimeout(()=> startTurtle(), sixStart + 600); // start turtle slightly after 6th appears
}

/* ========= Trigger final when turtle arrives (we check arrival inside loop) ========= */
/* already implemented in loop when turtle within small distance, it triggers triggerFinalBurst(); */

/* ========= Hook up UI ========= */
startBtn.addEventListener('click', ()=> startAll());
canvas.addEventListener('click', ()=> startAll());

/* ========= Allow pre-draw so it's not blank white ========= */
(function preDraw(){
  drawBackground(0);
  ctx.fillStyle = '#ddd';
  ctx.font = '20px "Segoe UI"';
  ctx.textAlign='center';
  ctx.fillText('Pulsa "Presiona aquí 🌼" para iniciar', W/2, H*0.6);
})();

</script>
</body>
</html>
